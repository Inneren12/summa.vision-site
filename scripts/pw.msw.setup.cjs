const { build } = require("esbuild");
const fs = require("node:fs/promises");
const path = require("node:path");

async function fileExists(targetPath) {
  try {
    await fs.access(targetPath);
    return true;
  } catch {
    return false;
  }
}

async function ensureNodePolyfillCrypto({ rootDir, workspaceDir }) {
  const relativePolyfillPath = path.join(
    "node_modules",
    "next",
    "dist",
    "server",
    "node-polyfill-crypto.js",
  );
  const workspacePolyfillPath = path.resolve(workspaceDir, relativePolyfillPath);

  if (await fileExists(workspacePolyfillPath)) {
    return;
  }

  const rootPolyfillPath = path.resolve(rootDir, relativePolyfillPath);
  const targetDir = path.dirname(workspacePolyfillPath);

  await fs.mkdir(targetDir, { recursive: true });

  if (await fileExists(rootPolyfillPath)) {
    const source = await fs.readFile(rootPolyfillPath, "utf8");
    await fs.writeFile(workspacePolyfillPath, source, "utf8");

    const sourceMapPath = `${rootPolyfillPath}.map`;
    if (await fileExists(sourceMapPath)) {
      await fs.writeFile(
        `${workspacePolyfillPath}.map`,
        await fs.readFile(sourceMapPath, "utf8"),
        "utf8",
      );
    }

    return;
  }

  const fallback = [
    "// Generated by scripts/pw.msw.setup.cjs",
    '"use strict";',
    "if (!global.crypto) {",
    "  try {",
    "    const crypto = require('node:crypto').webcrypto;",
    "    if (crypto) {",
    "      global.crypto = crypto;",
    "    }",
    "  } catch (error) {",
    "    console.warn('[PW MSW setup] Failed to polyfill globalThis.crypto:', error);",
    "  }",
    "}",
    "",
  ].join("\n");

  await fs.writeFile(workspacePolyfillPath, fallback, "utf8");
}

async function ensureNextWorkspaceMirror({ rootDir, workspaceDir }) {
  const relativeTarget = path.join("node_modules", "next");
  const workspaceNextPath = path.resolve(workspaceDir, relativeTarget);
  const rootNextPath = path.resolve(rootDir, relativeTarget);

  const sentinel = path.join(workspaceNextPath, "dist", "build", "output", "log.js");
  if (await fileExists(sentinel)) {
    return;
  }

  if (!(await fileExists(path.join(rootNextPath, "dist", "build", "output", "log.js")))) {
    return;
  }

  await fs.rm(workspaceNextPath, { recursive: true, force: true });
  await fs.mkdir(path.dirname(workspaceNextPath), { recursive: true });

  try {
    await fs.symlink(rootNextPath, workspaceNextPath, "dir");
    return;
  } catch (error) {
    console.warn("[PW MSW setup] Failed to symlink Next package, falling back to copy:", error);
  }

  await fs.cp(rootNextPath, workspaceNextPath, { recursive: true });
}

const rootDir = path.resolve(__dirname, "..");
const mswEntry = path.resolve(rootDir, "apps/web/test/msw/browser.ts");
const outputDir = path.resolve(rootDir, ".playwright", "msw");
const workspaceDir = path.resolve(rootDir, "apps/web");
const ensureWorkspaceReadyPromise = (async () => {
  await ensureNextWorkspaceMirror({ rootDir, workspaceDir });
  await ensureNodePolyfillCrypto({ rootDir, workspaceDir });
})();

async function globalSetup() {
  await ensureWorkspaceReadyPromise;

  const result = await build({
    entryPoints: [mswEntry],
    bundle: true,
    format: "iife",
    platform: "browser",
    write: false,
    target: ["es2020"],
    loader: { ".ts": "ts", ".json": "json" },
    define: {
      "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV ?? "test"),
    },
  });

  if (!result.outputFiles || result.outputFiles.length === 0) {
    throw new Error("Failed to build MSW browser bundle");
  }

  const [bundle] = result.outputFiles;
  const script = `${bundle.text}\nwindow.__mswStart?.();`;

  await fs.mkdir(outputDir, { recursive: true });
  const bundlePath = path.join(outputDir, "msw-init.js");
  await fs.writeFile(bundlePath, script, "utf8");

  process.env.PW_MSW_BUNDLE_PATH = bundlePath;
  process.env.PW_MSW_REDUCED_MOTION = process.env.PW_FORCE_REDUCED_MOTION ?? "";

  return async () => {
    delete process.env.PW_MSW_BUNDLE_PATH;
    delete process.env.PW_MSW_REDUCED_MOTION;
  };
}

module.exports = globalSetup;
