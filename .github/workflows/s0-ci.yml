name: "S0 Code-only Quality Checks"

on:
  push:
    branches: ["**"]
  pull_request:
    branches: ["**"]
  workflow_dispatch: {}

permissions:
  contents: read
  pull-requests: read

concurrency:
  group: "s0-ci-${{ github.ref }}"
  cancel-in-progress: true

jobs:
  s0:
    name: "S0 checks"
    runs-on: ubuntu-latest

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # PR-gate: forbid BIN in code-only PR
      - name: "Ensure no BIN files in PR"
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        with:
          script: |
            const exts = ['.png','.jpg','.jpeg','.svg','.ico','.webp','.avif','.gif','.woff','.woff2','.ttf','.otf','.pdf','.zip'];
            const pr = context.payload.pull_request;
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 200
            });
            const bin = files.data.filter(f => exts.some(e => f.filename.toLowerCase().endsWith(e)));
            if (bin.length) {
              core.setFailed("S0 (code-only): PR содержит бинарники:\n" + bin.map(b => ` - ${b.filename}`).join('\n'));
            }

      - name: "Setup Node (no cache yet)"
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: "Enable Corepack + PNPM"
        run: |
          set -e
          corepack enable
          corepack prepare pnpm@9.12.3 --activate
          pnpm -v

      - name: "Setup Node cache for pnpm (only if pnpm-lock.yaml exists)"
        if: ${{ hashFiles('pnpm-lock.yaml') != '' }}
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: "Install deps (pnpm if lockfile, otherwise npm; skip if no package.json)"
        run: |
          set -e
          if [ -f pnpm-lock.yaml ]; then
            echo "Using pnpm (lockfile found)"
            pnpm i --frozen-lockfile
          elif [ -f package-lock.json ]; then
            echo "Using npm ci (package-lock.json found)"
            npm ci
          elif [ -f package.json ]; then
            echo "Using npm i (package.json found)"
            npm i
          else
            echo "No package.json found; skipping install."
          fi

      - name: "Verify token source exists"
        run: |
          test -f tokens/brand.tokens.json || { echo "::error::missing tokens/brand.tokens.json"; exit 1; }
          echo "Found tokens/brand.tokens.json"

      - name: "Build tokens (CSS variables + TS export)"
        run: |
          set -e
          if [ -f package.json ] && npm run -s tokens:build >/dev/null 2>&1; then
            npm run -s tokens:build
            echo "tokens:build OK (package script)"
          elif [ -f scripts/build-tokens.ts ]; then
            npx -y tsx scripts/build-tokens.ts
            echo "tokens:build OK (direct tsx)"
          else
            echo "::error::No tokens builder found (add scripts/build-tokens.ts or a tokens:build script)"; exit 1
          fi
          test -f styles/tokens.css || { echo "::error::styles/tokens.css not generated"; exit 1; }
          test -f src/shared/theme/tokens.ts || { echo "::error::src/shared/theme/tokens.ts not generated"; exit 1; }

      - name: "No raw colors outside tokens"
        shell: bash
        run: |
          set -euo pipefail
          PATTERN='#[0-9A-Fa-f]{3,8}\b'
          dirs=()
          for d in src app styles og; do [ -d "$d" ] && dirs+=("$d"); done
          if [ ${#dirs[@]} -eq 0 ]; then
            echo "No code directories found (src/app/styles/og); skipping raw color scan."
            exit 0
          fi
          mapfile -t FILES < <(
            find "${dirs[@]}" \
              -type d \( -name node_modules -o -name .next -o -name dist -o -name tokens -o -name .storybook -o -path '*/src/shared/theme' \) -prune -o \
              -type f \( -name '*.ts' -o -name '*.tsx' -o -name '*.js' -o -name '*.jsx' -o -name '*.css' -o -name '*.html' \) \
              ! -path '*/styles/tokens.css' \
              -print
          )
          if [ ${#FILES[@]} -eq 0 ]; then
            echo "No eligible files to scan."
            exit 0
          fi
          > /tmp/raw_colors.txt
          grep -nE "$PATTERN" "${FILES[@]}" \
            | grep -v -E '(^|/|\\)src/shared/theme/tokens\.ts:' \
            | grep -v -E '(^|/|\\)styles/tokens\.css:' \
            > /tmp/raw_colors.txt || true
          sed -i 's/\r$//' /tmp/raw_colors.txt
          if [ -s /tmp/raw_colors.txt ]; then
            echo "### Raw color references found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            sed 's/\x1b\[[0-9;]*m//g' /tmp/raw_colors.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "::group::Raw color references (file:line:match)"
            cat /tmp/raw_colors.txt
            echo "::endgroup::"
            echo "::error::Found raw HEX colors outside tokens (see summary for details)."
            exit 1
          else
            echo "OK: no raw colors"
          fi

      - name: "Contrast sanity for core pairs"
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const TOK = JSON.parse(fs.readFileSync('tokens/brand.tokens.json','utf8'));
          const get = (o,p)=>p.split('.').reduce((x,k)=>x&&k in x?x[k]:undefined,o);
          const rgbToHex=(r,g,b)=>'#'+[r,g,b].map(n=>Math.max(0,Math.min(255,Math.round(n))).toString(16).padStart(2,'0')).join('');
          const parseCssRgb=s=>{const m=s.match(/^rgba?\(([^)]+)\)/i);if(!m)return null;const a=m[1].split(',').map(x=>x.trim());if(a.length<3)return null;return rgbToHex(+a[0],+a[1],+a[2])};
          function norm(val,d=0){if(d>6||val==null)return null;if(typeof val==='string'){const al=val.match(/^\{([^}]+)\}$/);if(al)return norm(get(TOK,al[1]),d+1);if(/^#?[0-9a-fA-F]{3,8}$/.test(val)){let s=val.startsWith('#')?val:'#'+val;if(s.length===4)s='#'+s[1]+s[1]+s[2]+s[2]+s[3]+s[3];return s.toUpperCase()}if(/^rgba?\(/i.test(val)){const h=parseCssRgb(val);return h?h.toUpperCase():null}return null}
            if(Array.isArray(val)&&val.length>=3&&val.every(n=>typeof n==='number'))return rgbToHex(val[0],val[1],val[2]).toUpperCase();
            if(typeof val==='object'){if('value'in val)return norm(val.value,d+1);if('$value'in val)return norm(val.$value,d+1);if('hex'in val)return norm(val.hex,d+1);if('r'in val&&'g'in val&&'b'in val)return rgbToHex(val.r,val.g,val.b).toUpperCase();if('light'in val)return norm(val.light,d+1);if('default'in val)return norm(val.default,d+1)}return null}
          function lin(u){u/=255;return u<=0.04045?u/12.92:Math.pow((u+0.055)/1.055,2.4)}
          function lum(h){const n=parseInt(h.replace('#',''),16);const R=lin((n>>16)&255),G=lin((n>>8)&255),B=lin(n&255);return 0.2126*R+0.7152*G+0.0722*B}
          function contrast(a,b){const L1=lum(a),L2=lum(b);const[hi,lo]=L1>L2?[L1,L2]:[L2,L1];return(hi+0.05)/(lo+0.05)}
          // brand-blue-500 светлый: проверяем тёмный текст на нём
          const PAIRS = [
            ['color.fg.default','color.bg.canvas'],
            ['color.fg.default','color.bg.surface'],
            ['color.fg.default','color.brand.blue.500']
          ];
          let ok=true;for(const[fgP,bgP]of PAIRS){const fg=norm(get(TOK,fgP)),bg=norm(get(TOK,bgP));if(!fg||!bg){console.log(`::warning::Cannot resolve ${fgP} on ${bgP} (fg=${fg}, bg=${bg})`);continue}const r=contrast(fg,bg);console.log(`${fgP} (${fg}) ON ${bgP} (${bg}) = ${r.toFixed(2)}:1`);if(r<4.5){console.log(`::error::Contrast < 4.5 (${r.toFixed(2)}) for ${fgP} on ${bgP}`);ok=false}}if(!ok)process.exit(1);
          NODE

      - name: "Install a11y deps (axe/jsdom) no-save"
        if: ${{ hashFiles('og/templates/*.html') != '' }}
        run: |
          npm i --no-save --no-package-lock --no-audit --no-fund axe-core@4.9.1 jsdom@23.2.0 glob@7.2.3

      - name: "Axe on OG templates (jsdom, ignore canvas & moderate)"
        if: ${{ hashFiles('og/templates/*.html') != '' }}
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const glob = require('glob');
          const { JSDOM, VirtualConsole } = require('jsdom');
          const axeCore = require('axe-core');
          const files = glob.sync('og/templates/*.html');
          if (!files.length) process.exit(0);
          (async () => {
            let blockers = 0;
            for (const file of files) {
              const html = fs.readFileSync(file, 'utf8');
              // Тихо игнорируем ошибки jsdom, связанные с canvas
              const vc = new VirtualConsole();
              vc.on('jsdomError', (e) => {
                const msg = String(e || '');
                if (msg.includes('HTMLCanvasElement.prototype.getContext')) return;
                console.warn(msg);
              });
              const dom = new JSDOM(html, {
                runScripts: "dangerously",
                resources: "usable",
                pretendToBeVisual: true,
                virtualConsole: vc,
                // ВАЖНО: заглушку ставим ДО выполнения любых скриптов шаблона
                beforeParse(window) {
                  try {
                    Object.defineProperty(window.HTMLCanvasElement.prototype, 'getContext', {
                      configurable: true,
                      writable: true,
                      value: () => ({
                        measureText: () => ({ width: 0 }),
                        drawImage() {},
                        fillRect() {},
                        getImageData() { return { data: [] }; },
                      }),
                    });
                  } catch {}
                }
              });
              const { window } = dom;
              const s = window.document.createElement('script');
              s.textContent = axeCore.source;
              window.document.head.appendChild(s);
              await new Promise((r) => {
                if (['interactive', 'complete'].includes(window.document.readyState)) r();
                else window.addEventListener('DOMContentLoaded', r, { once: true });
              });
              const res = await window.axe.run(window.document, { reporter: 'v2' });
              // Печатаем всё
              if (res.violations.length) {
                console.log(`A11y violations in ${file}: ${res.violations.length}`);
                for (const v of res.violations) {
                  console.log(`- ${v.id}: ${v.help} (${v.impact})`);
                  const n = v.nodes[0];
                  if (n) console.log(`  node: ${n.target.join(' ')}`);
                }
              }
              // Фейлим только на serious/critical (moderate — предупреждение)
              const hard = res.violations.filter(v => ['serious', 'critical'].includes(v.impact));
              if (hard.length) blockers++;
            }
            if (blockers) process.exit(2);
          })();
          NODE

      - id: detect_storybook
        name: "Detect Storybook deps"
        run: |
          set -e
          if [ ! -f package.json ]; then
            echo "has_storybook=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          HAS=$(
            node -e "try {
              const p = require('./package.json');
              const has = (deps) => deps && Object.keys(deps).some(d => d.startsWith('@storybook/'));
              process.stdout.write(String(has(p.dependencies) || has(p.devDependencies)));
            } catch (e) { process.stdout.write('false'); }"
          )
          echo "has_storybook=$HAS" >> "$GITHUB_OUTPUT"

      - name: "Build Storybook (optional if configured)"
        if: ${{ hashFiles('.storybook/**') != '' && steps.detect_storybook.outputs.has_storybook == 'true' }}
        run: |
          npx -y storybook@latest build --quiet
